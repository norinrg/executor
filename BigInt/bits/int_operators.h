/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

// from https://isocpp.org/files/papers/n4038.html

#ifndef INT_OPERATORS_H
#define INT_OPERATORS_H

#include <string>
#include <utility>

namespace std { namespace experimental { namespace seminumeric {

/* class integer */

    class integer;
    class integer_data_proxy;

    void swap(integer& lhs, integer& rhs) noexcept;

    // comparisons
    bool operator==(const integer& lhs, const integer& rhs) noexcept;
    bool operator!=(const integer& lhs, const integer& rhs) noexcept;
    bool operator<(const integer& lhs, const integer& rhs) noexcept;
    bool operator<=(const integer& lhs, const integer& rhs) noexcept;
    bool operator>(const integer& lhs, const integer& rhs) noexcept;
    bool operator>=(const integer& lhs, const integer& rhs) noexcept;

    // arithmetic operations
    integer operator+(const integer& lhs, const integer& rhs);
    integer operator-(const integer& lhs, const integer& rhs);
    integer operator*(const integer& lhs, const integer& rhs);
    integer operator/(const integer& lhs, const integer& rhs);
    integer operator%(const integer& lhs, const integer& rhs);

    std::pair<integer, integer> div(const integer& lhs, const integer& rhs);

    integer abs(const integer& val);

    integer operator<<(const integer& lhs, size_t rhs);
    integer operator>>(const integer& lhs, size_t rhs);

    // numeric operations
    integer sqr(const integer& val);
    integer sqrt(const integer& val);
    integer pow(const integer& val, const integer& exp);
    integer mod(const integer& lhs, const integer& rhs);
    integer mulmod(const integer& lhs, const integer& rhs, const integer& m);
    integer powmod(const integer& lhs, const integer& rhs, const integer& m);

    integer gcd(const integer& a, const integer& b);
    integer lcm(const integer& a, const integer& b);


    // conversions
    std::string to_string(const integer& val, int radix = 10);

    // I/O operations
    template <class CharT, class Traits>
        std::basic_ostream<CharT, Traits>& operator<<(
            std::basic_ostream<CharT, Traits>& str, const integer& val);
    template <class CharT, class Traits>
        std::basic_istream<CharT, Traits>& operator>>(
            std::basic_istream<CharT, Traits>& str, integer& val);

/* class bits */

    class bits;

    void swap(bits& lhs, bits& rhs) noexcept;

    // logical operations
    bits operator&(const bits& lhs, const bits& rhs);
    bits operator|(const bits& lhs, const bits& rhs);
    bits operator^(const bits& lhs, const bits& rhs);

    // I/O operations
    template <class CharT, class Traits>
        std::basic_ostream<CharT, Traits>& operator<<(
            std::basic_ostream<CharT, Traits>& str, const bits& val);
    template <class CharT, class Traits>
        std::basic_istream<CharT, Traits>& operator>>(
            std::basic_istream<CharT, Traits>& str, bits& val);

}}

template <class Ty> class numeric_limits;
template <> class numeric_limits<experimental::seminumeric::integer>;

template <class Ty> class hash;
template <> class hash<experimental::seminumeric::integer>;
template <> class hash<experimental::seminumeric::bits>;

}

#endif
